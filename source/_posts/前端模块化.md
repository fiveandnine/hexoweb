---
title: 前端模块化
date: 2019-10-25 16:19:24
tags:
---

## js命名空间使用
```aidl
const NAMESPACE = NAMESPACE || {}
NAMESPACE.hello = function(name){
  this.name = name
  console.log('hello' + name)
} 
NAMESPACE.getName = function(){
  return this.name
}

```
## 立即执行函数
```aidl
var module = function(){
  m1: function(){}
  m2: function(){}
  return {
    m1: m1,
    m2: m2
  }
}()
```
## 放大模式
```aidl
//module 提前定义，新的module添加了一个m3方法
var module = function(mod){
  mod.m3 = function(){}
  return mod
}(module)

```
## 宽放大模式
```aidl
var module = function(mod){
  //...
}(module || {})
```

## 输入全局变量
```aidl
var module = function($, AYHOO){
  
}(JQuery, YAHOO)

```
## AMD
### CommonJS
有一个全局变量的方法require()
### AMD
异步加载模块，加载完之后回调
```aidl
require('模块', callback)
```
requirejs解决的问题：
 1 实现js文件的异步加载，避免网页失去响应
 2 管理模块之间的依赖，易于维护
 ```aidl
<script async='true' defer src='require.js'></script>
<script src='require.js' data-main='src/main.js'></script>
```
data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。

AMD和CMD的最大的不同是对依赖的处理时机的不同

AMD依赖前置，谁是依赖立即加载
```aidl
require([module1, module2],function(module1, module2){

})
```
CMD就近依赖，需要把模块解析成字符串，才知道依赖了那些模块(这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。)
```aidl
define(function(require, exports, module){
  var clock = require('clock');
  clock.start();
})
```
### UMD
浏览器第一
```aidl
(function(window, factory){
  if(typeof exports === 'object'){
    module.exports = factory();
  }else if (typeof define === 'object' && define.amd){
    define(factory)
  }else{
    window.eventUtil = factory();
  }

})(this, function(){

})
```



#### 模块引用
node模块分为两类，核心模块和文件模块，通过require来引用模块

require主要功能是 读入并执行一个js文件，然后返回模块的exports对象，如果没发现模块就报错

#### 模块定义
一个文件就是一个模块，并通过 `module.exports` 和 `exports`导出模块的变量或函数
```aidl
module.exports = (a,b)=>{
    return a + b
}

exports.sum = (a,b)=>{
  return a + b
}
```
node为每个模块提供来一个`exports`对象，指向`module.exports`
```aidl
var exports = module.exports
```
```aidl
//test.js
module.exports = { a: 2 }
exports = { a: 1 }
-----
const a = require('./test.js') //2

```
require只导出module.exports的数据

注：
1. prototype创建的方法，则属于View的私有方法

2. 单次加载：上面这个例子有点类似于创建一个对象，但实际上和对象又有本质的区别，因为require 
不会重复加载模块，也就是说无论调用多少次 require， 获得的模块都是同一个。

#### 模块加载过程
 - 缓存加载
 缓存一般存放在`require.cache`中，
 - 路径解析
 - 文件定位
 - 编译执行
 
### es6



### es6模块和node模块
import属于es6模块，加载模块的引用而不是加载模块，直到真正使用到模块的时候才会去加载加载模块中的值。
#### requir动态态编译

require用于读取并执行js文件，并返回模块中的exports对象，若无指定模块会报错，commonjs模块加载模块是同步的，只有加载完成，才执行后面的操作

require是动态编译，第一次node加载模块的时候会缓存模块，后续加载的时候会从*缓存*中获取。*require
是运行时调用*，理论上可以在代码的任何地方运用。

#### import静态编译

import只生成引用，等到需要的时候此啊回去取值，不存在缓存，且模块中的变量绑定其他所在模块

import是编译是调用，虽然import命令具有提升效果，会提升到整个模块的头部

可以提高编译器效率，但是没有办法实现运行时加载。

因为require是运行时加载，所以import命令没有办法代替require的动态加载功能。

import为了实现动态加载， 引入了import()函数， 该函数返回一个promise对象。

```aidl
import(`./xxxx.js`)
  .then(module => {
    ...
  })
  .catch(err => {
    ...
  });
```
就是可能出现模块还没有加载完就被调用的情况， 此时会调用失败。

babel对于import的转码
```aidl
// es6Test.js
import * as actions from './searchAccount.actions';
import kdbTheme from '../../../common/Dialog/panguTheme.css';
import { createCommonAccount } from './createDialog.actions';

console.log('createCommonAccount###', createCommonAccount);
// babel编译es6Test.js
/* import * as actions from './searchAccount.actions' */
var _searchAccount = require('./searchAccount.actions'); 

var actions = _interopRequireWildcard(_searchAccount);

/* import kdbTheme from '../../../common/Dialog/panguTheme.css' */
var _panguTheme = require('../../../common/Dialog/panguTheme.css');

var _panguTheme2 = _interopRequireDefault(_panguTheme);

/* import { createCommonAccount } from './createDialog.actions'*/
var _createDialog = require('./createDialog.actions');

console.log('createCommonAccount###', _createDialog.createCommonAccount);

function _interopRequireWildcard(obj) { 
    if (obj && obj.__esModule) { return obj; } 
    else {
        var newObj = {}; 
        if (obj != null) { 
            for (var key in obj) { 
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; 
            } 
        } 
        newObj.default = obj; 
        return newObj; 
    } 
}

function _interopRequireDefault(obj) { 
    return obj && obj.__esModule ? obj : { default: obj }; 
}

```




[refer](https://juejin.im/post/5df0765be51d455825128f6d)

[refer](https://www.jianshu.com/p/33d53cce8237)

[refer](https://www.jianshu.com/p/ad427d8879cb)
