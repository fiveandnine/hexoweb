---
title: 前端模块化
date: 2019-10-25 16:19:24
tags:
---
### AMD

### CommonJS
#### 模块引用
node模块分为两类，核心模块和文件模块，通过require来引用模块

require主要功能是 读入并执行一个js文件，然后返回模块的exports对象，如果没发现模块就报错

#### 模块定义
一个文件就是一个模块，并通过 `module.exports` 和 `exports`导出模块的变量或函数
```aidl
module.exports = (a,b)=>{
    return a + b
}

exports.sum = (a,b)=>{
  return a + b
}
```
node为每个模块提供来一个`exports`对象，指向`module.exports`
```aidl
var exports = module.exports
```
#### 模块加载过程
 - 缓存加载
 缓存一般存放在`require.cache`中，
 - 路径解析
 - 文件定位
 - 编译执行
 
### es6

### UMD

### es6模块和node模块
import属于es6模块，加载模块的引用而不是加载模块，直到真正使用到模块的时候才会去加载加载模块中的值。
#### requir动态态编译

require用于读取并执行js文件，并返回模块中的exports对象，若无指定模块会报错，commonjs模块加载模块是同步的，只有加载完成，才执行后面的操作

require是动态编译，第一次node加载模块的时候会缓存模块，后续加载的时候会从*缓存*中获取。*require
是运行时调用*，理论上可以在代码的任何地方运用。

#### import静态编译

import只生成引用，等到需要的时候此啊回去取值，不存在缓存，且模块中的变量绑定其他所在模块

import是编译是调用，虽然import命令具有提升效果，会提升到整个模块的头部

可以提高编译器效率，但是没有办法实现运行时加载。

因为require是运行时加载，所以import命令没有办法代替require的动态加载功能。

import为了实现动态加载， 引入了import()函数， 该函数返回一个promise对象。

```aidl
import(`./xxxx.js`)
  .then(module => {
    ...
  })
  .catch(err => {
    ...
  });
```
就是可能出现模块还没有加载完就被调用的情况， 此时会调用失败。

babel对于import的转码
```aidl
// es6Test.js
import * as actions from './searchAccount.actions';
import kdbTheme from '../../../common/Dialog/panguTheme.css';
import { createCommonAccount } from './createDialog.actions';

console.log('createCommonAccount###', createCommonAccount);
// babel编译es6Test.js
/* import * as actions from './searchAccount.actions' */
var _searchAccount = require('./searchAccount.actions'); 

var actions = _interopRequireWildcard(_searchAccount);

/* import kdbTheme from '../../../common/Dialog/panguTheme.css' */
var _panguTheme = require('../../../common/Dialog/panguTheme.css');

var _panguTheme2 = _interopRequireDefault(_panguTheme);

/* import { createCommonAccount } from './createDialog.actions'*/
var _createDialog = require('./createDialog.actions');

console.log('createCommonAccount###', _createDialog.createCommonAccount);

function _interopRequireWildcard(obj) { 
    if (obj && obj.__esModule) { return obj; } 
    else {
        var newObj = {}; 
        if (obj != null) { 
            for (var key in obj) { 
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; 
            } 
        } 
        newObj.default = obj; 
        return newObj; 
    } 
}

function _interopRequireDefault(obj) { 
    return obj && obj.__esModule ? obj : { default: obj }; 
}

```
[参考](https://juejin.im/post/5df0765be51d455825128f6d)
