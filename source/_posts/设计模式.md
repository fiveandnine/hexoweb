---
title: 设计模式
date: 2019-12-13 19:44:26
tags:
   - js
---
# 设计模式
 - 结构型
 - 创建型
 - 行为型

## 结构型
### 外观模式
子系统接口提供统一的高层接口，抽取复杂逻辑进行抽象，提供更统一、更简洁、更易用api
```js
function addEvent (el, event, handler){
}
function removeEven(el, event, handler){
}
```
### 代理模式
 - 增加对象的访问控制
 - 当访问对象时需要有其他额外的操作
```js
class Person {
  constructor(props){
    this.name = props.name
    this.age = props.age
  }
}
const p = new Person({name: 'xx', age: 22})
const pp = new Proxy(p,{
  get: function(obj, key, receiver) {
    if(key === 'name'){
      return obj.name
    }
    return Reflect.get(obj, key, receiver)
  },
  set: function(obj, key, value, receiver){
    console.log(obj, key, value)
    return  Reflect.set(obj, key, value, receiver)
  }
})
```

## 创建型
### 工厂模式
```js
function factory(type) {
  switch (type) {
    case 'object':
      return new Object()
    case 'number':
      return new Number()
    default:
      return null
  }
}
```
### 单例模式
 - 一个class只有一个实例
 - 每次取到的实例都是同一个
 - 实例个数限制为一个
```js
function Single({name}) {
  this.name = name
}
const SingleFact = (function() {
  var sing;
  return {
    getSingle: function(pro){
      if(sing) return sing
      sing = new Single(pro)
      return sing
    }
  }
})()

SingleFact.getSingle()
```

## 行为模式
### 策略模式
对象有某个行为，但是在不同情况下此行为的表现也不同
```js
class Person {
  constructor(){}  
  setClose(){
    this.clothes = 'xxx'
  }
  Wear({time}){
    this.wearClose = `wear ${clothes} at ${time}`
  }
}

const person1 = new Person()

person1.setClose('xxx')
person1.wearClose({time: '1.pm'})
```
passport.js
```js
function LoginController(){
  this.stragety = null
  this.setStragety = (stragety)=>{
    this.stragety = stragety
    this.login = this.stragety.login
    return this
  }
}
function PhoneStragety() {
  this.login = ({id, verifyCode})=>{
    console.log(id, verifyCode)
        // authenticating with hone and verifyCode...
  }
}
app.use('/phone', function(req, res){
  loginController.setStragety(new PhoneStragety()).login(req)
})
```

### 迭代器模式interator
```js
const item = [1, 'red', false, 3.14];

item[Symbol.iterator] = function{
  var index = 0;
  return {
    next: ()=>{
      return {value: this[index],done : this[index++] === undefined  }
    }
  }
}

item[Symbol.iterator] = function*() {
  for(var index = 0; index< this.length; index ++)
    yield this[index];
}
```


### 观察者模式
被观察者发生变化，通过调用观察者的方法通知到观察者
```js
class Subject {
  constructor(){
    this.observer = []
  }
  add (observer){
    this.observer.push(observer)
    return this
  }
  remove (observer){
    this.observer = this.observer.filter(item => item.name!== 
    observer.name)
    return this
  }
  notisfy(data){
    this.observer.map(item => item.updata(data))
  }
  
}
class Observer {
  constructor(name){
    this.name = name
  }
  updata(data){
    console.log(`subject updata ${data} in (${this.name})`)
  }
}
const sub = new Subject()
const obs1 = new Observer('obs1')
const obs2 = new Observer('obs2')
sub.add(obs1).add(obs2)
sub.notisfy('xxx')
```
### 中介模式
聊天室
 
## 订阅发布模式
```js
class Sub  {
  constructor(){
    this.sub = {}
  }
  addListener(name, fn){
    if(this.sub[name]){
      this.sub[name].push(fn)
    }else{
      this.sub[name] = [fn]   
    }
  }
  emit(name,...args){
    this.sub[name] && this.sub[name].map(fn => fn.call(this,...args))
  }
  removeListener(name,callback){
    this.sub[name] && this.sub[name].filter(item !== callback)
  }
  once(name, fn){
    function once() {
      callback.apply(this, arguments);
      this.removeListener(name, fn)
    }
    this.addListener(name, once)
  }
}
```
[node-event]()

