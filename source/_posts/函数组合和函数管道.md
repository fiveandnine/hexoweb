---
title: 函数组合和函数管道
date: 2019-08-24 15:32:17
tags:
    - js
---

## 函数组合 compose
每个函数的输出作为另一个尚未可知程序的输入
```
function compose (...fns){
    <!--  -->
}

compose(fn1, fn2)(x) ===> fn1(fn2(x))
compose(fn1, fn2, f3)(x) ===> fn1(fn2(f3(x)))
```
函数开闭原则：软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的。

### 函数组合的实现
```
<!-- compose(fn1, fn2)(x) ===> fn1(fn2(x)) -->
function compose(fn1, fn2){
    return function(x){
        return fn1(fn2(x))
    }
}

<!-- compose(fn1, fn2, f3)(x) ===> fn1(fn2(f3(x))) -->
function compose(fn1, fn2, fn3){
    return function(x){
        return fn1(fn2(fn3(x)))
    }
}

function compose(...fns){
    return function(x){
        return fns.reduceRight(function(arg,fn){
            return fn(arg);
        },x)
    }
}
<!-- 管道 -->
function pipe(...fns){
    return function(x){
        return fns.reduce(function(arg,fn){
            return fn(arg);
        }, x)
    }
}

function pipeFn(...fns){
    return fns.reduce(prev, current => (...args)=> current(prev(...args)))
}

<!-- 项目 -->
function compose(...funcs) {
    if (funcs.length === 0) {
        return arg => arg
    }

    if (funcs.length === 1) {
        return funcs[0]
    }

    return funcs.reduce((a, b) => (...args) => a(b(...args)))
}
```
## 箭头函数和柯里化
柯里化：
1.延迟计算
  
2.参数复用
  
3.提前返回
  提前返回计算的部分结果（返回函数等待其他参数的调用）

```aidl
const result = users
  .filter(x => x.hasOwnProperty('pets'))
  .filter(x => x.hasOwnProperty('title'))
  
const has = (p) =>{
  return (o)=>{
    o.hasOwnProperty(p)
  }
}
const has2 = p => o => o.hasOwnProperty(p)
  
```
```aidl
const invert = x => (...args) => !x(...args);
const noPets = invert(hasPets);
let petlessUsersOldestFirst = users
  .filter(noPets)
  .sort(invert(sortBy('age')));

```
实例
```aidl
function add(a) {
    return function(b) {
        return a + b
    }
}
const add = a => b => a + b

```
[refer, Redux](https://zhuanlan.zhihu.com/p/33374547)
