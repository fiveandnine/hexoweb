---
title: 领域驱动
date: 2019-10-08 17:03:27
tags:
---


将每一块业务划分成不同的领域，各领域下包含哪些服务，每个页面调用的并不是 API 接口，而是各自领域的服务。

DDD的主要步骤分两步：
 - 挖掘领域概念，建立领域模型
 - 用代码实现领域模型
 
## 领域模型的特点
 - 领域的是有边界的，反映了领域内用户业务需求的本质
 - 领域模型只反应业务，和语言无关；不仅能反应实体概念，还能反应过程概念 
 - 软件业务逻辑集中在一个模型中，提高软件的可维护性，业务的可理解性和可重用性
 - 能够快速响应需求变化

## 领域驱动的概念
 ### 实体 entity
 
 "由一个它的标示定义的对象叫做实体"，通常具备唯一id
 ，能够持久化，具有业务逻辑，对应现实世界的业务对象。
  - 一个实体的基本概念是一个持续抽象的生命，可变化不同的形态和情况，但是总是有相同的标示。
  - 实体就是领域中需要唯一标识的领域概念
  - 实体上不应该有太多的属性或者行为，应该发现其他的一些实体的属性和行为，转移到其他关联的实体或者值对象上
 ### 值对象 value object
描述事物的对象，更准确的说是一个没有概念上的标识符描述一个领域方面的对象。这些对象是用来表示临时的事物，或者可以认为值对象是实体的属性，这些属性没有特性标识但同时表达了领域中某类含义的概念。
 
 - 如果两个对象的所有的属性的值都相同，我们会认为它们是同一个对象的话，那么我们就可以把这种对象设计为值对象。值对象在判断是否是同一个对象时是通过它们的所有属性是否相同，如果相同则认为是同一个值对象；而实体是否为同一个实体的区分，只是看实体的唯一标识是否相同，而不管实体的属性是否相同。

 - 关于实体与值对象的一个例子：比如员工信息的属性，如住址，电话号码都可以改变；然而，同一个员工的实体的标识将保持不变。因此，一个实体的基本概念是一个持续抽象的生命，可以变化不同的状态和情形，但总是有相同的标识。

 - 值对象不可变，只读。如果值对象是可共享的，它们应该是不可变的。（值对象应该保持尽量的简单）。         
 - 值对象的设计应尽量简单，不要让它引用很多其他的对象，因为本质上讲值对象只是代表一个值。
### 聚合和聚合根
聚合是用来定义领域对象所有权和边界的领域模式。聚合的作用是帮助简化模型对象间的关系。聚合，它通过定义对象之间清晰的所属关系和边界来实现领域模型的内聚，并避免了错综复杂的难以维护的对象关系网的形成。聚合定义了一组具有内聚关系的相关对象的集合，我们把聚合看作是一个修改数据的单元。

有分析报告显示，通常在大部分领域模型中，有70%的聚合通常只有一个实体，即聚合根，该实体内部没有包含其他实体，只包含一些值对象；另外30%的聚合中，基本上也只包含两到三个实体。这意味着大部分的聚合都只是一个实体，该实体同时也是聚合根。 
**并不是所有的实体都是聚集根，但只有实体才能成为聚集根**

### 工厂（factory）         
工厂用来封装创建一个复杂对象尤其是聚合时所需的知识，作用是将创建对象的细节隐藏起来。客户传递给工厂一些简单的参数，然后工厂可以在内部创建出一个复杂的领域对象然后返回给客户。当创建 实体和值对象复杂时建议使用工厂模式。

### 仓储（repositories）
仓储是用来管理实体的集合。

### service
推荐：最好显式声明服务，因为它创建了领域中一个清晰的特性，封装了一个概念领域层服务和基础设施层服务：均建立在领域实体和值对象的上层，以便直接为这些相关的对象提供所需的服务；
#### 领域服务和domain对象的区别
领域对象都是有状态和行为的，而领域服务没有状态只有行为。需要强调的是领域服务是无状态的，它存在的意义就是协调领域对象共同完成某个操作，所有的状态还是都保存在相应的领域对象中

## 领域驱动架构
### 层结构

#### user interface
展现曾用于向用户展现信息，并且会解析用户行为

#### Application layer
应用层没有任何的业务逻辑代码，它很简单，它主要为程序提供任务处理。比如service（领域服务层）

#### Domain Layer
这一层包含有关领域的信息，是业务的核心，领域模型的状态都直接或间接（持久化至数据库）存储在这一层。

#### Infrastructure Layer
为其他层提供底层依赖操作。
[refer](https://blog.csdn.net/admans/article/details/97828436)

## 领域驱动设计
提出领域的角色是需求方

每个需求都会对应到某个领域

例如 商品搜索 对应 商品中心域
    用户登陆 对应 用户信息&&鉴权域
    
从产品--后端--前端对应的领域相同


### 前端
1. 视图尽可能薄
2. 不写重复逻辑
3. 不同职责的代码进行分层 
4. 前端字段不受后端字段影响
5. 可纵观全局领域

![旧生命周期](/images/ddd/ddd.png)

## 实践
```
├── common
│   ├── components // 公用组件
│   ├── constants // 全局变量
│   │   ├── goods
│   │   │   └── index.js
│   │   ├── ...
│   ├── data-source // 数据接口层
│   │   ├── goods
│   │   │   ├── requestApis.js
│   │   │   └── translators.js
│   │   ├── ...
│   ├── domains // 领域层
│   │   ├── goods-domain
│   │   │   ├── entities // 实体
│   │   │   │   └── goods.js
│   │   │   └── goodsService.js // 领域Service服务
│   │   ├── ...
│   └── util // 公用函数
│       └── http.js
└── page // 页面视图层
    ├── index
    │   ├── App.js
    │   ├── components
    │   │   ├── GoodsItem.js
    │   │   ├── GoodsItem.scss
    │   │   ├── Nav.js
    │   │   └── Nav.scss
    │   ├── index.js
    │   └── services // 该页面需要用到的Service
    │       └── index.js
    ├── ...
```
数据层：进行数据的请求和处理，将字段名规范化或者做处理
领域层：
 - 实体：领域服务的载体，定义业务中某个个体的属性和方法。例如商品和购物车都可以抽象为实体，全局领域中是唯一的，不能出现在其他领域中。


[领域驱动设计在前端中的应用](https://github.com/Vincedream/ddd-fe-demo)
[refer](https://blog.csdn.net/qq773837256/article/details/52023905?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1)
